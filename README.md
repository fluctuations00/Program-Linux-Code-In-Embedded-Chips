# Program-Linux-Code-In-Embedded-Chips
Programming Linux style code with original manufactory, especially in Windows IDE


以往，常见的是如何用gcc编译ARM系列芯片，比如STM32，的代码，并在Linux环境下开发和仿真。也有干脆把Linux内核裁剪到极小尺寸后直接塞进STM32芯片。归根结底，都是希望能在Linux环境下开发STM32. 这么做的好处就是可以移植部分Linux的算法和代码做一些复杂的管理。坏处当然也有，第一就是Linux是宏内核，在别的芯片上很容易裁剪，但在相对小内存的STM32上，却是很难做到。第二个就是绝大部分嵌入式开发者，对Linux不熟，都是基于Windows开发环境开始STM32的历程，而原厂提供的Windows开发环境相对于Linux而言，相当高效，无论是编译器，还是仿真器，对初学者都有很大的亲和力。甚至那些企图挑战艰巨任务的资深工程师，也会发现Windows的debug环境要优于Linux环境，尤其是在对整个软硬件系统实时监控上。



对内核的改动主要是（1）把Linux的宏内核改成本文所依赖的微内核。（2）修改了部分内核算法，如内存管理算法。

宏内核与微内核的区别就是在内核里面继续分层，分离出一个微内核，也就是内核中的内核。但如何分层，即分层的策略其实和如何定义内核一样，都有很多选择。

首先我们了解一下什么是内核，在了解内核之前，先需要知道什么是算法。狭义的说，算法首先是数学计算的方法，中学生学过代数和几何的都知道，那就是所谓的解题思路。然后是对方法的提炼和抽象，用来解决类似问题的常用程序，用代码表示出来就是计算机程序。广义的说，算法就是解决一切可分类，可解析问题的常用方法。好，至此我们可以定义，操作系统就是广义算法程序化后在计算机上的集合。操作系统的概念和内核的概念还是有很大区别的，操作系统是软件的集合，是个静态的东西。而内核是指运行中的程序，这部分程序运行在与具体用户无关的上下文空间，使用系统内部的namespace，或者说能访问用户看不到的全局变量，有着更严格的规范和保护。

那什么是微内核呢，形象的说，就是对内核内部的各线程重新包装。就如同一袋苹果，有些人只用一个袋子装，有些人把每个苹果装进一个小的袋子。微内核既是如此，它把内核中的每个子系统进一步封装成可独立运行，把子系统间的交互更加复杂化，设置更厚的壁垒，比如几个子系统间的全局变量改成局部变量，只能通过管道访问。这样能保证一个子系统的更新或者被完全替换都不会影响别的子系统。

本文中，我们将看到进程调度、消息管理，内存调度子系统完全被替换，而文件管理，sound和网络管理基本保持原样。进程调度可以被不止一种算法替换，比如可以用uCos，也可以用freeRTOS算法来替换。消息管理和内存管理都是如此，可以根据自己喜好随意处置，只要满足封装要求，保证接口不变，不影响namespace。而Linux的文件管理和设备驱动管理正是我们整个项目的精神支柱，当然需要原汁原味保留。